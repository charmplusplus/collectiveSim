module allGather {
  readonly double alpha;
  readonly double beta;

  message allGatherMsg;

  array[1D] AllGather {
    entry AllGather(int size, int n, int type);
    entry[reductiontarget] void initdone(int num);
    entry void startGather();
    entry void recvDefault(int sender, CkNcpyBuffer data, double recvTime);
    entry void local_buff_done(CkDataMsg *m);
    entry void Hypercube() {
      for(iter = 0; iter < numHypercubeIter; iter++) {
        serial { HypercubeToSend = thisIndex ^ ((int)pow(2, iter)); }
        if (HypercubeToSend < n) {
          serial {
            CkNcpyBuffer data[hyperCubeStore.size()];
            int dataIndx[hyperCubeIndx.size()];
            int numBuffers = hyperCubeStore.size();
            for(int i = 0; i < numBuffers; i++) {
              data[i] = hyperCubeStore[i];
              dataIndx[i] = hyperCubeIndx[i];
            }
#ifdef TIMESTAMP
            thisProxy(HypercubeToSend).recvHypercube(iter, data, dataIndx, numBuffers, (timeStamp + alpha + beta * hyperCubeStore.size() * 8));
            timeStamp += alpha;
#else
            thisProxy(HypercubeToSend).recvHypercube(iter, data, dataIndx, numBuffers, 0.0);
#endif
          }
          when recvHypercube[iter](int ref, CkNcpyBuffer data[size], int dataIndx[size], int size, double recvTime) {
            serial {
              for(int m = 0; m < size; m++) {
                hyperCubeStore.emplace_back(data[m]);
                hyperCubeIndx.emplace_back(dataIndx[m]);
                CkNcpyBuffer dst(store + dataIndx[m] * k, k * sizeof(long int), zero_copy_callback, CK_BUFFER_UNREG);
                dst.get(data[m]);
              }
#ifdef TIMESTAMP
              timeStamp = std::max(recvTime, timeStamp);
#endif
            }
          }
        }
      }
    };
    entry void recvHypercube(int ref, CkNcpyBuffer data[size], int dataIndx[size], int size, double recvTime);
    entry void Flood(int sender, CkNcpyBuffer data, double recvTime);
  };
};
